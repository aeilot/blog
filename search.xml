<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>P3147 USACO16OPEN 262144 P 题解</title>
      <link href="/2022/11/24/P3147-262144P/"/>
      <url>/2022/11/24/P3147-262144P/</url>
      
        <content type="html"><![CDATA[<p>DP 系列。</p><a id="more"></a><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>看题，<a href="https://www.luogu.com.cn/problem/P3147">Luogu</a></p><p>合并相邻的相同数字，变成数字加一。求获得的最大值。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>最初想到的是基础的区间 DP，不做解释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>; len&lt;=N; len++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i+len<span class="number">-1</span>&lt;=N; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> y = i+len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k&lt;y; k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(DP[i][k] == DP[k+<span class="number">1</span>][y])&#123;</span><br><span class="line">                DP[i][y] = <span class="built_in">max</span>(DP[i][y], DP[i][k] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, DP[i][y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>但是 $ 2 \leq n \leq 262144 $ ，显然会 MLE。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>借鉴思路，我们发现可以使用类似倍增的方法去做。</p><p>用状态 <code>f[i][j]</code> 表示 合成之后结果为 i，右端点为 j 的区间的左端点位置，如果 值为 0 即 不可行。</p><p>因为题目要找两个相邻相等的区间，合成。有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f[i][j] = f[i<span class="number">-1</span>][f[i<span class="number">-1</span>][j]];</span><br><span class="line"></span><br><span class="line">把 f[i][j] 拆分成两个能合成为 i<span class="number">-1</span> 的区间</span><br></pre></td></tr></table></figure><p>即</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                 f[i<span class="number">-1</span>][j]</span><br><span class="line">    |------&lt;i<span class="number">-1</span>&gt;-----|----&lt;i<span class="number">-1</span>&gt;-----|</span><br><span class="line">    j                      f[i<span class="number">-1</span>][f[i<span class="number">-1</span>][j]] </span><br><span class="line"></span><br><span class="line">如果 f[i<span class="number">-1</span>][j] 或 f[i<span class="number">-1</span>][f[i<span class="number">-1</span>][j]] 不成立，f[i][j] 就不成立，即转移为 <span class="number">0</span></span><br></pre></td></tr></table></figure><p>那如何表示结果？</p><p>记录 <code>ans</code>，如果 <code>f[i][j]</code> 可行，就更新 <code>ans</code>。因为 <code>i</code> 递增，所以不需要 <code>max</code> 操作。</p><p>得到</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">2</span>; i&lt;=<span class="number">58</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=N; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!DP[i][j])&#123;</span><br><span class="line">            DP[i][j] = DP[i<span class="number">-1</span>][DP[i<span class="number">-1</span>][j]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(DP[i][j])&#123;</span><br><span class="line">            ans = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们倍增合并，所以 $log_2{262144} + 40 = 58$ 是可能获得的最大值。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>显然不合并是可行的，所以在输入的时候，初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=N; i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> in;</span><br><span class="line">    cin &gt;&gt; in;</span><br><span class="line">    DP[in][i] = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 <code>i+1</code>：为了避免区间重复，我们 <code>f[i][j]</code> 表示的区间是左闭右开区间，所以右端点是 <code>i+1</code></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这道题是区间 DP 状态优化，DP 学习之路漫漫，还需要多加练习。</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> DP </tag>
            
            <tag> 区间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3354 Riv 河流 题解</title>
      <link href="/2022/11/23/riv-p3354/"/>
      <url>/2022/11/23/riv-p3354/</url>
      
        <content type="html"><![CDATA[<p>最近在练树形 DP，正好看到 <a href="https://www.luogu.com.cn/problem/P3354">这一道</a> 虚标的紫题，但本蒟蒻不会写，想出来了便记录一下</p><a id="more"></a><h2 id="题面-amp-思考"><a href="#题面-amp-思考" class="headerlink" title="题面 &amp; 思考"></a>题面 &amp; 思考</h2><p>先看题面，一颗有根树，选定 k 个节点作为 ”伐木场“，求运送木料最小费用。注意木料费用是 <code>dis * wood</code>。</p><p>最开始想到简单的树形背包，状态转移方程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i][k] = <span class="built_in">min</span>(f[j][s] + cost, f[i][k]);</span><br></pre></td></tr></table></figure><p>但是注意到，如果某个后代节点如果是伐木场，cost 不需要计算，所以状态中还需要存储后代的伐木场情况。</p><p>但是后代中锯木厂不止一个。考虑到树有唯一的父亲，且同一深度祖先唯一，可以记录最近的伐木场祖先，作为状态的一部分。</p><p>有 <code>f[i][j][k]</code> 即 i 节点 最近的伐木场祖先为 j，后代（不算自己）有 k 个是伐木场。</p><p>但是由于 f 自己也可能是伐木场，转移方程不同，需要分类讨论，于是改成：<code>f[i][j][k][0/1]</code> 其中 0 代表自己<strong>不是</strong>伐木场， 1 表示自己<strong>是</strong>伐木场。</p><h2 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h2><p>因为我们需要枚举祖先，在 DFS 时需要记录 Fa 数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DFS 开始时：fa[++tot] = x;</span><br><span class="line"></span><br><span class="line">结束时：tot--;</span><br></pre></td></tr></table></figure><p>简单记录祖先 stack。</p><p>回溯后，对于当前节点 <code>x</code> 和 子节点 <code>y</code> 每个祖先 <code>ff</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">先对每个 k 赋初值，对于每种伐木场个数 l：</span><br><span class="line">f[x][ff][l][<span class="number">0</span>] += f[y][ff][<span class="number">0</span>][<span class="number">0</span>]; --&gt; 当前节点不是伐木场，子节点 y 最近伐木场为 l，对任意 f，赋最大值，即 子结点中没有伐木场。</span><br><span class="line"></span><br><span class="line">f[x][ff][l][<span class="number">1</span>] += f[y][x][<span class="number">0</span>][<span class="number">0</span>]; --&gt; 当前节点是伐木场，子节点 y 最近伐木场为 当前节点，对任意 f，赋最大值，即 子结点中没有伐木场。</span><br></pre></td></tr></table></figure><p>然后就是树形背包：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f[x][ff][l][<span class="number">0</span>] = <span class="built_in">min</span>(f[x][ff][l][<span class="number">0</span>], f[x][ff][l-s][<span class="number">0</span>] + f[y][ff][s][<span class="number">0</span>]); --&gt; 当前节点不是伐木场，对 y 节点分配 s 个伐木场个数</span><br><span class="line">f[x][ff][l][<span class="number">1</span>] = <span class="built_in">min</span>(f[x][ff][l][<span class="number">0</span>], f[x][ff][l-s][<span class="number">1</span>] + f[y][x][s][<span class="number">0</span>]); --&gt; 当前节点是伐木场，对 y 节点分配 s 个伐木场个数</span><br><span class="line"></span><br><span class="line">唯一的不同是 y 节点最近祖先为 x</span><br></pre></td></tr></table></figure><p>注意在枚举 l 时，由于是01背包，需要倒过来枚举，不然状态计算会叠加。（很容易理解）</p><p>做完了？好像还差一个 cost！</p><p>考虑到 祖先节点 <code>ff</code> cost 的贡献，因为是 当前节点 W 乘以 到 <code>ff</code> 的总距离！</p><p>需要计算总距离，维护 <code>dep</code> 数组，即当前节点到根节点距离，即可！很容易理解。<code>ff</code> 到 <code>x</code> 的距离就是 <code>dep[x] - dep[ff]</code></p><p>对于当前节点 <code>x</code> 每一个祖先 <code>ff</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(l&gt;=<span class="number">1</span>)&#123; --&gt; 因为 l 需要 <span class="number">-1</span> ，要分类讨论。</span><br><span class="line">    f[x][ff][l][<span class="number">0</span>] = <span class="built_in">min</span>(f[x][ff][l][<span class="number">0</span>] + W[x] * (dep[x]-dep[ff]), f[x][ff][l][<span class="number">1</span>]);</span><br><span class="line">    合并 <span class="number">0</span> 和 <span class="number">1</span>，因为回溯之后，<span class="number">1</span> 的状态不再被使用，便于下一步计算。</span><br><span class="line">    <span class="number">-1</span> 是因为上文 f[x][ff][l][<span class="number">1</span>] = <span class="built_in">min</span>(f[x][ff][l][<span class="number">0</span>], f[x][ff][l-s][<span class="number">1</span>] + f[y][x][s][<span class="number">0</span>]); 时，s+l-s = l 但是当前节点也是伐木场，所以状态更新是 l+<span class="number">1</span> 的，要 <span class="number">-1</span> 获取正确结果</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    l = <span class="number">0</span> 时，当前节点不可能为伐木场，直接添加到 ff 增加的贡献</span><br><span class="line">    f[x][ff][l][<span class="number">0</span>] += W[x] * (dep[x]-dep[ff]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里再来聊一聊合并。为了便于讨论，上文背包转移的时候，我们没有考虑 <code>y</code> 的 1 的情况，而是在每次 <code>y</code> 回溯时 合并 0 和 1。这有点类似于滚动数组？回溯后 <code>0</code> 不再表示之前的意义，而是我们最初设计的状态：i 节点 最近的伐木场祖先为 j，后代（或自己）有 k 个是伐木场！</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, d;</span><br><span class="line">&#125; NDS[<span class="number">201</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[<span class="number">201</span>], vis[<span class="number">201</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> W[<span class="number">201</span>];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    NDS[cnt].to = b;</span><br><span class="line">    NDS[cnt].next = head[a];</span><br><span class="line">    NDS[cnt].d = d;</span><br><span class="line">    head[a] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">201</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">201</span>][<span class="number">201</span>][<span class="number">52</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dep[<span class="number">201</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    fa[++tot] = x;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i != <span class="number">-1</span>; i = NDS[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = NDS[i].to;</span><br><span class="line">        <span class="keyword">if</span> (vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">        dep[y] = dep[x] + NDS[i].d;</span><br><span class="line">        <span class="built_in">dp</span>(y);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = tot; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> ff = fa[j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = k; l &gt;= <span class="number">0</span>; l--) &#123;</span><br><span class="line">                f[x][ff][l][<span class="number">0</span>] += f[y][ff][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">                f[x][ff][l][<span class="number">1</span>] += f[y][x][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> s = l; s&gt;=<span class="number">0</span>; s--)&#123;</span><br><span class="line">                    f[x][ff][l][<span class="number">0</span>] = <span class="built_in">min</span>(f[x][ff][l][<span class="number">0</span>], f[x][ff][l-s][<span class="number">0</span>] + f[y][ff][s][<span class="number">0</span>]);</span><br><span class="line">                    f[x][ff][l][<span class="number">1</span>] = <span class="built_in">min</span>(f[x][ff][l][<span class="number">1</span>], f[x][ff][l-s][<span class="number">1</span>] + f[y][x][s][<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ff = fa[j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = k; l &gt;= <span class="number">0</span>; l--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">                f[x][ff][l][<span class="number">0</span>] = <span class="built_in">min</span>(f[x][ff][l][<span class="number">0</span>] + W[x] * (dep[x]-dep[ff]), f[x][ff][l<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                f[x][ff][l][<span class="number">0</span>] += W[x] * (dep[x]-dep[ff]);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; x &lt;&lt; &quot; &quot;&lt;&lt;ff &lt;&lt; &quot; &quot;&lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; f[x][ff][l][0] &lt;&lt; &quot; &quot; &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; dep[x] &lt;&lt; endl;</span></span><br><span class="line">    tot--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Type your code here</span></span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> w, v, d;</span><br><span class="line">        cin &gt;&gt; w &gt;&gt; v &gt;&gt; d;</span><br><span class="line">        W[i] = w;</span><br><span class="line">        <span class="built_in">add</span>(i, v, d);</span><br><span class="line">        <span class="built_in">add</span>(v, i, d); <span class="comment">// 链式前向星</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dp</span>(<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; f[<span class="number">0</span>][<span class="number">0</span>][k][<span class="number">0</span>] &lt;&lt; endl; <span class="comment">// 输出结果，注意是 合并后，所以是 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> DP </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>层雾</title>
      <link href="/2022/11/21/the-fog-1/"/>
      <url>/2022/11/21/the-fog-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>花非花，雾非雾。夜半来，天明去。来如春梦几多时，去似朝云无觅处。<br><a id="more"></a></p></blockquote><p>今晨，上海下着一场大雨，天色阴沉。床上蒙了一层水汽，更远处便是层层雾霭之下的昔日无比熟悉的河川景致。</p><p>出门。雨敲击在雨伞上发出有节奏的声音，四周其实也有些许走着的行人。但这些都离我太远了。雨带给我的只有那本就属于我的失意。</p><p>回想 2020 到现在，时光匆匆，几乎不能感知时光的流逝。但它终究还是溜走了！而且似乎在一瞬间！旧日的一幕幕，如今还在疾速流去的时光之河。我想让它停下来，是的一定要停下来。反复思索，琢磨，这样在低沉中的循环是否是生命的本质，诘问我们是否真的有能力改变我们的未来，改变命运的走向。或许掌握仅仅是自我麻醉。我们或许从未掌控过什么。也许我们仅仅是回忆，也许我们从未存在，也许我们存在过，也许眼前的一切都是虚幻。没有人知道答案。</p><p>层雾遮盖住眼前的道路，看向四周的人。我总觉得陌生，而无所适从，总觉得不安。毕竟在层雾中的人，找不到方向。我好像从来都没有得到内心深处的满足，从未有过，在短暂的逝去的岁月里。未来也不会有吧？毕竟我们没有能力决定我们的来去，甚至连自己最基本的属性都不能决定，没有能力。我们的开场都是天命。</p><p>到了。站立在灯光微弱的走廊里，四周是一片空虚。时间太早了，没有什么人。</p><p>人生是这样吗？逝去的岁月是这样吗？</p><p>“花非花，雾非雾。夜半来，天明去。来如春梦几多时，去似朝云无觅处。”</p><p>也许是我沉溺在对无意义的追索中，或者仅仅是过去的痛苦太愉快了，又或者是我已经被单调麻醉？生活最初的样子？</p><p>忽然来了两个孩童，蹦起来按下电灯开关。</p><p>眼前一片明朗，就像昨日的阳光。</p><p>”也许明天也是这样。“</p><p>谁知道呢？但是 C’est la vie.</p><p>层雾，……</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 散文 </tag>
            
            <tag> 情感 </tag>
            
            <tag> 天气日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马拉车算法</title>
      <link href="/2022/11/20/manacher/"/>
      <url>/2022/11/20/manacher/</url>
      
        <content type="html"><![CDATA[<p>最近在学习马拉车算法，简单记录一下心得。（如有疏漏，请指出</p><a id="more"></a><p>先看 <a href="https://www.luogu.com.cn/problem/P3805">模板题</a> ，要求最长回文串的长度。</p><p>首先思考朴素算法，显然是 $O(n^3)$ ，无法通过。而马拉车算法能将时间复杂度优化到 $O(n)$。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul><li>对于一个回文字符串，必然有一个对称中心，在对称中心两侧的部分均全等。</li><li>一个回文字符串对称之后得到的一定也是回文字符串<br>即 aba <strong>x</strong> aba<ul><li>但是对于奇数、偶数长度的回文字符串，这个对称中心可能是字符，也可能在两个字符中间。<br>如：ab <strong>|</strong> ba, a <strong>b</strong> a</li></ul></li></ul><p>所以考虑，在两个字符中间都插入隔板 <code>#</code>，即 <code>abba</code> 变成 <code>#a#b#b#a#</code>。原长度为 <code>n</code> 的字符串，增加 <code>n+1</code> 隔板，长度变成 <code>2n+1</code> 必然是奇数，方便统计。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>马拉车算法，即记录一直最长回文子串区间，对朴素算法进行优化。</p><p>因为是朴素算法两侧向外拓展，隔板对判断回文无影响。<code>p[i]</code> 数组存储以 <code>str[i]</code> 为对称中心的回文字符串半径长度。半径长度中计算了隔板个数，所以得到的就是回文字符串长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">-1</span>;i&lt;s2.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (i&gt;r)? <span class="number">1</span> : <span class="built_in">min</span>(p[l+r-i], r-i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span> &lt;= i-k &amp;&amp; i+k&lt;s2.<span class="built_in">size</span>() &amp;&amp; s2[i-k]==s2[i+k])&#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    p[i] = --k; <span class="comment">// 注意最后一次循环会对加上一个 1</span></span><br><span class="line">    <span class="keyword">if</span>(i+k&gt;r)&#123;</span><br><span class="line">        l = i-k;</span><br><span class="line">        r = i+k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先记录 <code>i</code>，枚举每个对称中心，记录 <code>l</code> 和 <code>r</code> 即目前最长回文字符串的左右端点。<code>k</code> 则是目前半径长度。</p><p>算法主体就是朴素算法，向左右两端拓展。</p><p>考虑优化。如果<code>i</code>处在一个回文子串中，因为对称性，可以得到与<code>i</code>对称的点<code>j</code>的最长回文串长度。因为<code>i</code>不断增加，对称的点的坐标一定小于<code>i</code>即已经更新过。</p><p>由于上文推断的性质，回文子串可以对称得到。注意单个字符也可以考虑成一个回文子串。所以 <code>k</code> 可以从 之前的 <code>p[j]</code> 开始计算。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(设 x 表示 [l,r] 对称中心，j 就是 i 关于 x 的对称点)</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 案例1</span><br><span class="line">l       r</span><br><span class="line"><span class="section">#a#b#b#a#</span></span><br><span class="line">  ^ ^ ^</span><br><span class="line">  j x i</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 案例2</span><br><span class="line">l     r</span><br><span class="line"><span class="section">#a#b#a#b#a#b#a#</span></span><br><span class="line">   ^   ^   ^</span><br><span class="line">   j   x   i</span><br><span class="line"></span><br><span class="line">手推方便理解</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后考虑如何计算 <code>j</code>，因为中点坐标公式，得到 $\frac{l+r}{2} = \frac{i+j}{2} = mid$ ，得到 $j = l+r-i$。</p><p>但是因为确定区间，且偶数情况存在。所以还应判断 <code>j</code> 是否在区间内。</p><p>而如果不在区间内，很显然应该从<code>1</code>开始枚举。</p><p>所以得到：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k = (i&gt;r)? <span class="number">1</span> : <span class="built_in">min</span>(p[l+r-i], r-i+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><br>每次更新 <code>l</code> <code>r</code> 区间长度即可。</p><h2 id="AC-Code"><a href="#AC-Code" class="headerlink" title="AC Code"></a>AC Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">110000001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Type your code here</span></span><br><span class="line">    string s1;</span><br><span class="line">    cin &gt;&gt; s1;</span><br><span class="line">    string s2;</span><br><span class="line">    s2.<span class="built_in">resize</span>(s1.<span class="built_in">size</span>()*<span class="number">2</span>+<span class="number">4</span>);</span><br><span class="line">    s2[<span class="number">0</span>] = <span class="string">&#x27;~&#x27;</span>;</span><br><span class="line">    s2[<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j=<span class="number">2</span>; i&lt;s1.<span class="built_in">size</span>(); i++, j+=<span class="number">2</span>)&#123;</span><br><span class="line">        s2[j] = s1[i];</span><br><span class="line">        s2[j+<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">-1</span>;i&lt;s2.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = (i&gt;r)? <span class="number">1</span> : <span class="built_in">min</span>(p[l+r-i], r-i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">0</span> &lt;= i-k &amp;&amp; i+k&lt;s2.<span class="built_in">size</span>() &amp;&amp; s2[i-k]==s2[i+k])&#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        k--;</span><br><span class="line">        p[i] = k;</span><br><span class="line">        <span class="keyword">if</span>(i+k&gt;r)&#123;</span><br><span class="line">            l = i-k;</span><br><span class="line">            r = i+k;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>马拉车算法实用且容易理解，但熟练掌握还需要练习。</p><p><a href="https://www.luogu.com.cn/problem/P4555">作业 | 最长双回文串</a></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 模版 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>夜雨</title>
      <link href="/2022/11/18/rain-at-night-1/"/>
      <url>/2022/11/18/rain-at-night-1/</url>
      
        <content type="html"><![CDATA[<p>太久没更博客了，别来无恙</p><a id="more"></a><blockquote><p>2020.11.16 日夜雨有感，18日记</p></blockquote><p>夜雨一直下，下在这小城的一隅。</p><p>从广场走出，漆黑一片，不远处却是车水马龙，仿佛隔了一个世界。雨伞下，近乎看不清的霓虹渐明了。但此刻我只见到微光下如丝的雨和它有节奏地击打在伞面上的声音。</p><p>这是冬日的雨，路旁伫立，晶莹的雨点散在大衣的绒毛上，形成了彩色的泪珠。我知道这和去年此刻的景一样。伫立，长叹，冉冉升起的白色雾霭是对这喧嚣的叛逆。</p><p>风起，微寒，但雨下如同泪涟涟，不知何时终了。</p><p>上了车，向车后望去，移动的灯火与车流、人流，在夜的深邃中，形成红色的流动的丝绸飘带。车窗外的世界总是呈现怀旧的昏黄，而这生活的千篇一律着实让人麻木。在自己的热爱织成的茧中窒息，在对旧日的追忆中迷失。西西弗斯式地在单调中沉沦，无可救药，我亲手造成了自我的慢性自杀。</p><p>脑海中涌动的昨日，如同白纸，毫无意义。微寒，放松，我似乎又找回了去年此刻的心境。身体却是轻盈，御风而行，泠然善也。我知道过去成就今日，而此刻我仍然陷入迷茫却清醒的叠加态，是循环往复的轮回的孤独。</p><p>窗外的雨一如去年、前年、渐渐被忘却的过往，落地就无法挽回的过往。那些，我已经找不到了，于是只能叹息。这是人生最大的 BUG，过去的就不能再来，经历就是一种失去。</p><p>人生。</p><p>改变？</p><p>一切尽在车窗外夜雨的缄默里。</p><p>而我。</p><p>我还是我吗？</p><p>这些话，何止今日说起过呢？</p><p>换一种思维方式，换一种生活，换一种人生，突破过去的茧，重获新生。</p><p>人生不再千篇一律。真正的自我解放。</p><p>但夜雨不会停。因为没有办法让它停下来。</p><p>但天亮了就会是新的一天。</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 散文 </tag>
            
            <tag> 情感 </tag>
            
            <tag> 天气日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从愚人节玩笑到真的玩笑(bushi): 浅谈 lsnotes</title>
      <link href="/2022/04/15/lsnotes/"/>
      <url>/2022/04/15/lsnotes/</url>
      
        <content type="html"><![CDATA[<p>离了个大谱 (不过这个想法挺好的<br><a id="more"></a></p><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>愚人节本来是开玩笑的，结果发现，挺有用。笑死</p><p>前几天和朋友讨论，说要给每个目录加个提示语，<code>ls</code> <code>pwd</code> <code>cd</code> 这些命令时显示出来。</p><p>e.g.:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">The place <span class="built_in">where</span> I code!</span><br><span class="line">---</span><br><span class="line">Demo  OI  Playground  Projects</span><br></pre></td></tr></table></figure><p>这样就解决了，目录那么多，自己甚至都忘了这个干啥了的情况。当然，还有很多其他的用法，比如可以在 <code>.lsnotes</code> 中显示 build 方式。</p><h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p><code>lsnotes</code> 是个<del>水项目</del>，目前只支持纯文本显示（未来会加上 Markdown 解析，短时间内先鸽了。</p><p>就目前的代码量而言，小学生都会写…</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p><a href="https://github.com/MrWillCom">MrWillCom</a> 又做了一个更强的 <code>lsnotes</code> 即 <a href="https://github.com/MrWillCom/lnn">lnn</a>。</p><p>这个项目功能简单，但实用，未来不怎么会维护了。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 纪念品分组</title>
      <link href="/2021/10/01/Luogu-P1094/"/>
      <url>/2021/10/01/Luogu-P1094/</url>
      
        <content type="html"><![CDATA[<p>快要 CSP-S2 了，复习一下一些算法（弄文化课弄了好久了，很多东西都要忘了。。。</p><a id="more"></a><h2 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h2><p><a href="https://www.luogu.com.cn/problem/P1094">题目链接: Luogu P1094</a></p><p>看题，<strong>把购来的纪念品根据价格进行分组，但每组最多只能包括两件纪念品</strong>。看样子，应该是贪心。每次取一个大的，一个小的，就可以保证了。如果大的小的组合起来，超过了最大值，就只取大的。</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>很容易就可以写出程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ar[<span class="number">30001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, w;</span><br><span class="line">    cin &gt;&gt; w &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; ar[i];</span><br><span class="line">    <span class="built_in">sort</span>(ar, ar + n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &gt;= l) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ar[l] + ar[r] &lt;= w) &#123;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r--;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>可以参考<a href="https://www.luogu.com.cn/blog/heidoudou/solution-p1094">这个</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>能力有限，如有疏漏，请谅解并补充，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 导弹拦截</title>
      <link href="/2021/10/01/Luogu-P1020/"/>
      <url>/2021/10/01/Luogu-P1020/</url>
      
        <content type="html"><![CDATA[<p>快要 CSP-S2 了，复习一下一些算法（弄文化课弄了好久了，很多东西都要忘了。。。</p><a id="more"></a><h2 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h2><p><a href="https://www.luogu.com.cn/problem/P1020">题目链接: Luogu P1020</a></p><p>数据是这样的：<code>389 207 155 300 299 170 158 65</code></p><p>推一推，我们发现，<code>389 300 299 170 158 65</code>是第一问的答案；在 <code>155-&gt;300</code>的时候，要使用另外一颗炮弹了，故最少应该配备两套。</p><p>在草稿纸上面推一推，不难发现，这道题的两小问，就是让你求一个<code>不上升序列长度</code>和一个<code>上升序列长度</code>。</p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>在求这两个东西之前，需要先学习<code>STL</code>中的两个函数：<code>lower_bound</code> <code>upper_bound</code>。</p><p>其中， <code>lower_bound</code> 是求序列中第一个<strong>大于等于</strong>某个数的数；<code>upper_bound</code> 是求序列中第一个<strong>大于</strong>某个数的数。这两个函数返回的是<strong>指针</strong>。</p><p>它们使用的前提是 序列是<strong>有序</strong>的。</p><p>以lower_bound为例，具体用法类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">lower_bound</span>(a, a+len, x); <span class="comment">// 前两个参数传入的都是指针</span></span><br></pre></td></tr></table></figure><p>这一函数默认是求升序序列中符合条件的数，如果要改为降序序列，则需要一个 <code>cmp</code> 函数，这一点类似于 <code>sort</code>。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">lower_bound</span>(a, a+len, x, std::greater&lt;<span class="keyword">int</span>&gt;()); <span class="comment">// 前两个参数传入的都是指针</span></span><br></pre></td></tr></table></figure><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>我的 <a href="https://github.com/aeilot/ProblemSet/blob/master/LuoGu/P1020/main.cpp">AC 代码</a>。</p><p>本题有两种算法，$O(n)$，$O(nlogn)$。这里只讲后者。</p><h3 id="不上升序列"><a href="#不上升序列" class="headerlink" title="不上升序列"></a>不上升序列</h3><p>我们用数组<code>d1</code>当作栈来存储它。</p><p>遍历导弹高度，把栈顶元素和高度比较：</p><ol><li>若 $a_i &lt;= d_len$，此时$a_i$是符合要求的，直接入栈。</li><li>若 $a_i &gt; d_len$，此时$a_i$把栈内第一个小于它的覆盖掉。这里说一下，能够覆盖它是因为我们不需要再访问它的值了。在测试数据中，此后几次都会进行这一操作，如果仅仅取这几个数据，最长不上升子序列长度仍然正确； 取所有数据，几次操作之后，就会执行操作1，结果仍然正确。</li></ol><h3 id="上升序列"><a href="#上升序列" class="headerlink" title="上升序列"></a>上升序列</h3><p>和不上升序列一样，只不过把 <code>upper_bound</code> 改为了 <code>lower_bound</code>，因为会出现两个相同高度的导弹的情况，这两个导弹仅仅需要同一的炮弹去拦截。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ARR[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> d1[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">int</span> c1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> d2[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">int</span> c2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; ARR[n]) n++;</span><br><span class="line">    d1[<span class="number">0</span>] = ARR[<span class="number">0</span>];</span><br><span class="line">    d2[<span class="number">0</span>] = ARR[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ARR[i] &lt;= d1[c1])</span><br><span class="line">            d1[++c1] = ARR[i];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="built_in">upper_bound</span>(d1, d1 + c1, ARR[i], greater&lt;<span class="keyword">int</span>&gt;()) - d1;</span><br><span class="line">            d1[j] = ARR[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ARR[i] &gt; d2[c2])</span><br><span class="line">            d2[++c2] = ARR[i];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="built_in">lower_bound</span>(d2, d2 + c2, ARR[i]) - d2;</span><br><span class="line">            d2[j] = ARR[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; c1 + <span class="number">1</span> &lt;&lt; endl &lt;&lt; c2 + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>能力有限，如有疏漏，请谅解并补充，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何高效使用搜索引擎</title>
      <link href="/2021/08/27/search-engine/"/>
      <url>/2021/08/27/search-engine/</url>
      
        <content type="html"><![CDATA[<p>这篇文章已经在 <a href="https://github.com/aeilot/HowToUseSearchEngines">GitHub</a> 开源了。</p><a id="more"></a><p>最近遇到一些人不太会用搜索引擎，就写了这篇文章。。。有不对的地方，或者要补充的地方希望大家踊跃评论、PR。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#简介">简介</a></li><li><a href="#认识搜索引擎">认识搜索引擎</a><ul><li><a href="#搜索引擎的代表">搜索引擎的代表</a></li></ul></li><li><a href="#如何高效检索">如何高效检索</a><ul><li><a href="#言简">言简</a></li><li><a href="#意骇">意骇</a></li></ul></li><li><a href="#高级技巧">高级技巧</a><ul><li><a href="#一举多得">一举多得</a></li><li><a href="#让搜索引擎为你做减法">让搜索引擎为你做减法</a></li><li><a href="#我只想看这一个网站怎么办">我只想看这一个网站怎么办</a></li><li><a href="#限定文件格式">限定文件格式</a></li><li><a href="#限定网址">限定网址</a></li><li><a href="#限定标题">限定标题</a></li><li><a href="#告诉搜索引擎搜索的是作品">告诉搜索引擎搜索的是作品</a></li><li><a href="#告诉搜索引擎不要拆开关键词">告诉搜索引擎不要拆开关键词</a></li></ul></li><li><a href="#推荐阅读">推荐阅读</a></li><li><a href="#特别鸣谢">特别鸣谢</a></li><li><a href="#参考资料">参考资料</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近我经常遇到一些同学，经常跑来问我一些很明显在搜索引擎上面就可以搜到的问题。我问他们为什么不去网上搜，却发现其实他们搜过，只是效果不好：有些人直接把一整个问句打上去了，还有人漏关键字。这些都是他们没有掌握搜索引擎使用的精髓。所以，我写了这个教程，帮助解决搜索引擎的使用问题。</p><h2 id="认识搜索引擎"><a href="#认识搜索引擎" class="headerlink" title="认识搜索引擎"></a>认识搜索引擎</h2><p>我这里说的搜索引擎是指网络搜索引擎。下面给出<a href="https://zh.wikipedia.org/wiki/网络搜索引擎">维基百科</a>中的定义：</p><blockquote><p>网络搜索引擎（英语：web search engine）是设计在万维网上进行搜索，意思是指自动从万维网搜集特定的信息，提供给用户进行查询的系统。</p></blockquote><p>搜索引擎的工作原理大致可以分为搜集信息、整理信息和接受查询。<strong>为了使文章简单，更深入的知识我在这里就不展开了，本文以如何使用为主。</strong> </p><h3 id="搜索引擎的代表"><a href="#搜索引擎的代表" class="headerlink" title="搜索引擎的代表"></a>搜索引擎的代表</h3><ul><li><a href="https://www.baidu.com">百度</a></li><li><a href="https://www.bing.com">必应</a></li><li><a href="https://www.sogou.com">搜狗</a></li><li><a href="https://www.so.com">360搜索</a></li><li><a href="https://www.google.com">谷歌</a></li><li><a href="https://yandex.com">Yandex</a></li></ul><p>还有学术型搜索引擎：</p><ul><li><a href="https://xueshu.baidu.com">百度学术</a></li><li><a href="https://scholar.google.com">谷歌学术</a></li></ul><h2 id="如何高效检索"><a href="#如何高效检索" class="headerlink" title="如何高效检索"></a>如何高效检索</h2><p>我认为，高效检索只需要注意：言简、意骇</p><h3 id="言简"><a href="#言简" class="headerlink" title="言简"></a>言简</h3><p>言简，顾名思义，就是让你的搜索尽可能更简单。在搜索的时候，应该对问题提取关键词。比如，我想要知道<code>高锰酸钾制取氧气的文字表达式是什么</code>时，我仅仅需要写<code>高锰酸钾制取氧气 文字表达式</code> 即可；同样的，在查询<code>怎么写检讨书时</code>，甚至只需搜索<code>检讨书</code>；在想知道<code>《将进酒》是谁写的</code>，只用查询<code>将进酒 作者</code>。如果不确定要搜索的内容名称，应该做更少的准确限定，换为更零散的关键词。如果是英文，则应去除复数和第三人称复数。虽然某些搜索引擎在进行查询的时候会自动去除掉 「xxx的xxx」这种词汇和标点符号，但在搜索时还是应该尽量减少他们的使用。也尽可能不要出现 「如何」「怎样」这些疑问词，更不需要和搜索引擎讲礼貌——不要出现类似「请问寒假什么时候放假？」而是写成「寒假放假时间」。</p><h3 id="意骇"><a href="#意骇" class="headerlink" title="意骇"></a>意骇</h3><p>意骇，就是把你的搜索描述的尽可能完备。不要一昧地追求简单，在有些情况下还是需要给出限定的：比如，在搜索<code>苹果</code>时，如果你指的是水果的苹果，那为了提升效率，最好写<code>苹果 水果</code>；同理，想要搜索苹果公司，则应该写<code>苹果 公司</code>，这可以简化为<code>苹果公司</code>。如果不进行限定，有可能搜索结果第一页都会被此关键词的其他意思所充满，在搜寻时，就会降低效率。</p><p>更加高级的限定方法，请见<a href="#高级技巧">高级技巧</a>。</p><h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><h3 id="一举多得"><a href="#一举多得" class="headerlink" title="一举多得"></a>一举多得</h3><p>如果我在搜索的时候，想同时获得多个关键词的结果，我可以使用 <code>|</code>，即“或”。<strong>注意：用<code>|</code>分隔关键词的时候，一定要加上空格，<code>|</code>必须要是半角的</strong>，举个例子：<code>东京 | 塔</code>。</p><h3 id="让搜索引擎为你做减法"><a href="#让搜索引擎为你做减法" class="headerlink" title="让搜索引擎为你做减法"></a>让搜索引擎为你做减法</h3><p>如果我在搜索的时候，不想获得某个关键词的结果，我可以使用 <code>-</code>，即“减”。<strong>注意：用<code>-</code>，一定要在之前加上空格</strong>，举个例子：<code>苹果 -水果</code>。</p><h3 id="我只想看这一个网站怎么办"><a href="#我只想看这一个网站怎么办" class="headerlink" title="我只想看这一个网站怎么办"></a>我只想看这一个网站怎么办</h3><p>如果我只想获得某个网站的结果，可以在<strong>整个搜索之前或之后</strong>加上 <code>site:xxx网站</code>，比如：<code>site:blog.aeilot.top 数码</code>。</p><h3 id="限定文件格式"><a href="#限定文件格式" class="headerlink" title="限定文件格式"></a>限定文件格式</h3><p>如果我只想搜索一种格式的文件，可以在<strong>整个搜索之前或之后</strong>加上 <code>filetype:xxx网站</code>，比如：<code>filetype:pdf 物理课本</code>。不指定文件类型搜索文件时，可以使用<code>filetype:all</code>。</p><h3 id="限定网址"><a href="#限定网址" class="headerlink" title="限定网址"></a>限定网址</h3><p>如果我想让我的搜索结果的网址都包含某一字断，可以加上 <code>inurl:xxx</code>，比如：<code>inurl:pan PPT模版</code>，就可以找到网址带<code>pan</code>的所有相关结果。</p><h3 id="限定标题"><a href="#限定标题" class="headerlink" title="限定标题"></a>限定标题</h3><p>如果我想让我的搜索结果的标题都包含某一字断，可以加上 <code>intitle:xxx</code>，比如：<code>intitle:免费 PPT模版</code>，就可以找到标题带<code>免费</code>的所有相关结果。</p><h3 id="告诉搜索引擎搜索的是作品"><a href="#告诉搜索引擎搜索的是作品" class="headerlink" title="告诉搜索引擎搜索的是作品"></a>告诉搜索引擎搜索的是作品</h3><p>如果我搜索的是作品，如文学作品、艺术作品，可以加上书名号，比如：<code>《星际穿越》</code>。</p><h3 id="告诉搜索引擎不要拆开关键词"><a href="#告诉搜索引擎不要拆开关键词" class="headerlink" title="告诉搜索引擎不要拆开关键词"></a>告诉搜索引擎不要拆开关键词</h3><p>如果我不想要拆开搜索的关键词，可以加上引号，比如：<code>“九年级化学“</code></p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ol><li><a href="https://www.zhihu.com/question/28013848">知乎 - 如何高效地使用搜索引擎</a></li></ol><h2 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h2><ul><li><a href="https://github.com/MrWillCom">MrWillCom</a> 他对我的创作进行了指导。</li><li><a href="https://github.com/QD-lazy-tm">Cathy Aeilot</a> 她启发了我写这份教程。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://zh.wikipedia.org/wiki/网络搜索引擎">网络搜索引擎 — 维基百科</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 生产力 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索引擎 </tag>
            
            <tag> 效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 GitHub Actions 格式化 C/C++ 代码</title>
      <link href="/2021/08/20/gh-action-clang-format/"/>
      <url>/2021/08/20/gh-action-clang-format/</url>
      
        <content type="html"><![CDATA[<p>我的 <a href="https://github.com/aeilot/ProblemSet/blob/master/.github/workflows/clang-format.yml">ProblemSet</a> 项目，每次都 Format 太麻烦了，需要一个自动化 Format 的功能。利用 GitHub Actions，即可实现。</p><a id="more"></a><h2 id="GitHub-Actions"><a href="#GitHub-Actions" class="headerlink" title="GitHub Actions"></a>GitHub Actions</h2><p><a href="https://docs.github.com/en/actions">GitHub Actions</a> 是 GitHub 推出的持续集成服务，最近不要钱了，用(白嫖)的人就多起来了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>直接上代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">name:</span> <span class="string">&quot;Check Clang Format&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>, <span class="string">pull_request</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">format:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;Run Clang Format&quot;</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;Install clang-format&quot;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          sudo apt-get update</span></span><br><span class="line"><span class="string">          sudo apt-get install clang-format-10</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;Format Codes&quot;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">clang-format-10</span> <span class="string">-style=file</span> <span class="string">-i</span> <span class="string">*/*/*.cpp</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Push</span> <span class="string">changes</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions-go/push@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">author-name:</span> <span class="string">Clang</span> <span class="string">Format</span> <span class="string">Bot</span></span><br><span class="line">          <span class="attr">commit-message:</span> <span class="string">Run</span> <span class="string">clang-format</span></span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如果大家有什么改进的好方法，可以在下方评论！</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四季的天空</title>
      <link href="/2021/07/19/pylon-in-seasons/"/>
      <url>/2021/07/19/pylon-in-seasons/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用单反拍摄，Louis Aeilot 版权所有，所有图片都未经过后期处理，仅经过压缩。</p></blockquote><p>拍摄用时1年，就是每次看到了都会去拍一张。</p><a id="more"></a><p><img data-src="https://i.loli.net/2021/07/19/x7TQcN3EK85vgAP.jpg" alt="IMAGE 2020"><br><img data-src="https://i.loli.net/2021/07/19/UbSXKw9LquYGFCZ.jpg" alt="IMAGE 2020"><br><img data-src="https://i.loli.net/2021/07/19/uDqfpNb1KULycQE.jpg" alt="IMAGE 2020"><br><img data-src="https://i.loli.net/2021/07/19/ZiycGIMw93nmJb6.jpg" alt="IMAGE 2020"><br><img data-src="https://i.loli.net/2021/07/19/CIYFgQJy1L6owKt.jpg" alt="IMAGE 2021"></p>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>洛谷 7 月月赛 Div.2 总结</title>
      <link href="/2021/07/15/luogu-lgr087/"/>
      <url>/2021/07/15/luogu-lgr087/</url>
      
        <content type="html"><![CDATA[<p>昨天(7/14)参加了洛谷的 7 月月赛，感觉题目挺新颖的，就是数据有点。。。</p><a id="more"></a><p>比赛链接：<a href="https://www.luogu.com.cn/contest/46177">这里</a></p><p>我的代码在 <a href="https://github.com/aeilot/ProblemSet/tree/master/Competition/LuoGu-2021July-Div2">这里</a></p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>乍一看好像没思路，但是想一想，其实很简单，就是会有几种情况：</p><ol><li><strong>0个空格</strong> 全是数字的话，需要判断一下 A. 两者完全相同 B. 非A，情况 A 是可以输出 <code>Yes</code> 的。</li><li><strong>1个空格</strong> 这一种情况，从原理上分析，“选择一个有正整数的格子和一个与之相邻的空格子，将正整数移到那个空格子中”，可以得出，其实只要顺时针转一圈，初始和最终状态顺序相同，就符合条件。所以，只需要做三次判断即可，简单粗暴（在座的各位大佬要是有高端方法可以通知一下🙇）。</li><li><strong>2、3、4个空格</strong> 这几个情况，经过分析会发现，不管如何，都是满足条件的。</li></ol><p>所以，这样分析下来，很简单就 AC 了，拿到 100 分！</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><blockquote><p>这道题。。。无语了。。。测试数据通过了，结果测评数据每次都卡一个，万恶的捆绑测试。。。最后得不了 100 分了。。。</p></blockquote><p>这道题最开始想的是贪心算法，排序，但是会超时，就改了一下：开两个数组，不管顺序，只管符号，放进去。这样做基本上不超过 10ms。</p><p>原理就是，计算 <code>+正数</code> <code>+负数</code> <code>*正数</code> <code>*负数</code> 出现的个数，进行排列，最后计算结果。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote><p>因为学业原因，离开了几个小时，回来了之后都没时间做了。。。有点思路，但没写完。。。</p></blockquote><p>其实，可以根据数第一次出现的位置判断从左、右数的位置，最后进行排列即可。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>看了一眼就懒得写。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>等题解吧！感觉题目很有意思，都是些需要仔细思考的题目。(奈何我太弱了。。。太弱小了！！！</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 最近公共祖先 (LCA)</title>
      <link href="/2021/04/24/Luogu-P3379/"/>
      <url>/2021/04/24/Luogu-P3379/</url>
      
        <content type="html"><![CDATA[<p>好久没刷题了，复习一下：LCA。</p><a id="more"></a><h2 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a>题目详情</h2><p>题目很简单，就是求多叉树两个点的最近公共祖先。</p><p>链接: <a href="https://www.luogu.com.cn/problem/P3379">洛谷 P3379</a></p><blockquote><p>LCA（Least Common Ancestors），即最近公共祖先，是指在有根树中，找出某两个结点u和v最近的公共祖先。 ———来自百度百科</p></blockquote><p><img data-src="https://i.loli.net/2021/04/24/3XCbi4Lrd8Sxnst.png" alt="818487-20151004150339121-181913844.png"><br>图中，4 和 3 的 LCA 就是 1。</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="最简单的方法-暴力"><a href="#最简单的方法-暴力" class="headerlink" title="最简单的方法 (暴力)"></a>最简单的方法 (暴力)</h3><blockquote><p>这种方法数据一大就会TLE。</p></blockquote><p>原理很简单，让两个数一个一个向上走，直到两个数相遇。第一次相遇就是他们的 LCA。</p><p>很简单，就不赘述了，直接上代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 500000</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; tree[MAX];<span class="comment">// 以邻接表形式存储</span></span><br><span class="line"><span class="keyword">int</span> dep[MAX];</span><br><span class="line"><span class="keyword">int</span> fas[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> M1 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fa != <span class="number">-1</span>) &#123;</span><br><span class="line">            dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fas[x] = fa;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree[x].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fas[tree[x].<span class="built_in">at</span>(i)] == <span class="number">-2</span>) M1::<span class="built_in">dfs</span>(tree[x].<span class="built_in">at</span>(i), x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fas[a] == fas[b]) &#123;</span><br><span class="line">                <span class="keyword">return</span> fas[a];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fas[b] == a) &#123;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fas[a] == b) &#123;</span><br><span class="line">                <span class="keyword">return</span> b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> da = dep[a], db = dep[b];</span><br><span class="line">            <span class="keyword">int</span> delta = <span class="built_in">abs</span>(da - db);</span><br><span class="line">            <span class="keyword">if</span> (da &gt; db) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; delta; i++) &#123;</span><br><span class="line">                    a = fas[a];</span><br><span class="line">                    da = dep[a];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (da &lt; db) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; delta; i++) &#123;</span><br><span class="line">                    b = fas[b];</span><br><span class="line">                    db = dep[b];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a = fas[a];</span><br><span class="line">                da = dep[a];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">// namespace M1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first) &#123;</span><br><span class="line">        M1::<span class="built_in">dfs</span>(r, <span class="number">-1</span>);</span><br><span class="line">        first = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    res = M1::<span class="built_in">solve</span>(a, b);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n, s;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; i++) &#123;</span><br><span class="line">        dep[i] = <span class="number">0</span>;</span><br><span class="line">        fas[i] = <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        tree[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        tree[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    dep[s] = <span class="number">0</span>;</span><br><span class="line">    fas[s] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="built_in">LCA</span>(a, b, s);</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这道题目的数据输入，<code>x y</code> <strong>表示x 结点和 y 结点之间有一条直接连接的边（数据保证可以构成树）。</strong> 所以需要用邻接表的形式，表示多叉树。</p><h3 id="倍增法"><a href="#倍增法" class="headerlink" title="倍增法"></a>倍增法</h3><p>这个算法是对上面暴力算法的优化。这个算法的时间复杂度为$O(nlogn)$，已经可以满足大部分的需求。</p><p>上述算法中，一步一步跳太慢了，这里我们事先做好标记，就可以每次 $2^i$ 步向上跳，一直到相遇。</p><p>代码中有较为详细的注释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 500001 <span class="comment">// 本题最大数据规模</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUL_MAX 22</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; tree[MAX]; <span class="comment">// 以邻接表形式存储</span></span><br><span class="line"><span class="keyword">int</span> dep[MAX]; <span class="comment">// 预处理存储节点深度</span></span><br><span class="line"><span class="keyword">int</span> fas[MAX][MUL_MAX]; <span class="comment">// 存储 x 节点上面第 2^i 次方个祖先</span></span><br><span class="line"><span class="keyword">bool</span> first = <span class="literal">true</span>; <span class="comment">// 记录预处理是否结束</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lg2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">log</span>(x) / <span class="built_in">log</span>(<span class="number">2</span>) + <span class="number">1</span>; <span class="comment">// 无理数计算记得加上 1 来避免误差</span></span><br><span class="line">&#125; <span class="comment">// 手动写了一个函数，来求 log2(x)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123; <span class="comment">// x 是当前节点，fa 是它的父节点</span></span><br><span class="line">    <span class="keyword">if</span> (fa != <span class="number">-1</span>) &#123;</span><br><span class="line">        dep[x] = dep[fa] + <span class="number">1</span>; <span class="comment">// x 的深度就是它的父节点加一，这很好理解</span></span><br><span class="line">    &#125;</span><br><span class="line">    fas[x][<span class="number">0</span>] = fa; <span class="comment">// x 节点的第一个父节点是 fa</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= dep[x]; i++) &#123; <span class="comment">// 循环直至 2^i 大于当前节点深度，即完成当前节点到树根的所有可跳转到的节点的预处理工作</span></span><br><span class="line">        fas[x][i] = fas[fas[x][i - <span class="number">1</span>]][i - <span class="number">1</span>]; </span><br><span class="line">        <span class="comment">// 这一步是算法的精髓</span></span><br><span class="line">        <span class="comment">// 得到状态转移方程，动态规划计算</span></span><br><span class="line">        <span class="comment">// 意思是x的2^i祖先等于x的2^(i-1)祖先的2^(i-1)祖先</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree[x].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[x].<span class="built_in">at</span>(i) != fa) <span class="built_in">dfs</span>(tree[x].<span class="built_in">at</span>(i), x); </span><br><span class="line">        <span class="comment">// 邻接表存储当前节点所有相连的节点，只要节点不是它的父节点，即节点是它的子节点，就进行下一步递归</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 深度优先搜索来预处理一下</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[b] &gt; dep[a]) <span class="built_in">swap</span>(a, b); <span class="comment">// 确保 a 的深度更深，避免冗余的判断</span></span><br><span class="line">    <span class="keyword">while</span> (dep[a] &gt; dep[b]) &#123;</span><br><span class="line">        a = fas[a][<span class="built_in">lg2</span>(dep[a] - dep[b]) - <span class="number">1</span>]; <span class="comment">// a 向上跳，跳至两节点同级</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a; <span class="comment">// 若此时两节点相遇，就可以直接返回。否则两节点还需再次向上跳。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">lg2</span>(dep[a]); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fas[a][i] != fas[b][i]) &#123;</span><br><span class="line">            a = fas[a][i];</span><br><span class="line">            b = fas[b][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 从可跳到的最高处向下枚举，得到 LCA</span></span><br><span class="line">    <span class="keyword">return</span> fas[a][<span class="number">0</span>]; <span class="comment">// 返回答案</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first) &#123;</span><br><span class="line">        dep[r] = <span class="number">0</span>;</span><br><span class="line">        fas[r][<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(r, <span class="number">-1</span>);</span><br><span class="line">        first = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    res = <span class="built_in">solve</span>(a, b);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n, s;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; i++) &#123;</span><br><span class="line">        dep[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; MUL_MAX; j++)</span><br><span class="line">            fas[i][j] = <span class="number">-2</span>;</span><br><span class="line">    &#125; <span class="comment">// 数组初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        tree[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        tree[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="comment">// 邻接表存入数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="built_in">LCA</span>(a, b, s);</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实还可以预处理出一个 <code>lg</code> 数组，避免对数计算，大家可以自己去尝试，会有一定时间优化效果。</p><p>无法理解倍增？这里有个 <a href="https://blog.csdn.net/jarjingx/article/details/8180560">经典资料</a></p><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p>实际上还有更快的方法求这道题的答案。倍增算法已经可以满足需求，就不再往下写了。</p><ul><li>Tarjan</li><li>ST 算法</li></ul><p>大家有兴趣可以去尝试一下。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这里放上两种列出算法的评分。</p><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p><img data-src="https://i.loli.net/2021/04/24/UF9g4PefzQ8lrYL.png" alt="截屏2021-04-24 下午6.13.14.png"></p><h3 id="倍增"><a href="#倍增" class="headerlink" title="倍增"></a>倍增</h3><p><img data-src="https://i.loli.net/2021/04/24/G2qxQDSBCuNYm89.png" alt="截屏2021-04-24 下午6.13.08.png"></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 模版 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用简单的物理方法证明牛顿莱布尼茨公式</title>
      <link href="/2020/12/25/newton-leibniz-proof/"/>
      <url>/2020/12/25/newton-leibniz-proof/</url>
      
        <content type="html"><![CDATA[<p>前几天经过苦思冥想，想出来了一种简单的证明方法，现在来简单分享一下。<br><a id="more"></a></p><h2 id="关于牛顿莱布尼茨公式"><a href="#关于牛顿莱布尼茨公式" class="headerlink" title="关于牛顿莱布尼茨公式"></a>关于牛顿莱布尼茨公式</h2><p>即微积分基本定理。</p><script type="math/tex; mode=display">\int_a^b f(x)dx = F(b) - F(a) = F(x)\bigg|_a^b</script><p>其中，$F(x)$ 为 $f(x)$ 原函数。</p><h2 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h2><p>有初中物理知识可以知道，在 v-t 图像中，面积就是位移，两点间面积之差就是时间差的积分。</p><p>所以很容易证明出这一定理。</p><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>所以 v-t 函数的原函数就是 s(t) 函数，所以 [a,b] 区间内的位移就是 $s(t)\bigg|_a^b$</p><p>而上文已经得出 v(t) 函数在 [a,b] 区间的积分也指的是位移。</p><p>所以很容易得出要证明的结论。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本人仅是业余爱好进行学习，若有不足，请指正。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学与数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
            <tag> 微积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简评荣耀手环6</title>
      <link href="/2020/12/25/honor-band6/"/>
      <url>/2020/12/25/honor-band6/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2020/12/25/bL2k4lVvfWIKxJp.png" alt="Band"></p><p>前几天买了个 <strong>荣耀手环6</strong>，简单点评点评。</p><a id="more"></a><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><strong>屏幕</strong>在一般的手环里算是比较大的，比较全面屏，颜值也挺高的。</li><li><strong>续航</strong>把类似自动运动监测、心率检测、压力检测之类的打开了之后都有一个星期的续航。</li><li><strong>离线支付宝、NFC</strong>真的很方便。</li><li>etc</li></ul><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><ul><li><strong>表盘</strong>，说实在的，真得没有小米的好看，还不支持自定义，希望以后能适配。话说。。。这设计者怕不是喝了假酒(bushi)。</li><li><strong>非华为系手机</strong>用不了一些特别功能，比如心脏健康什么的，不过可以破解，自行搜索。</li><li><strong>24小时血氧检测</strong>这个功能是不支持的。</li></ul><h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><p>第一次买华为系的产品（不过现在荣耀已经分离了），感觉还挺好。</p><p>就是希望官方能够加强自定义功能和对于非华为手机，特别是苹果手机的适配。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一款产品还是非常值得买的，当然，这里不建议苹果用户购买NFC版本，不然很多功能无法使用。</p><p>价格：标准版 249，NFC 289</p>]]></content>
      
      
      <categories>
          
          <category> 数码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>海上生明月，天涯共此时。</title>
      <link href="/2020/10/01/mid-autumn-2020/"/>
      <url>/2020/10/01/mid-autumn-2020/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用单反拍摄，Louis Aeilot 版权所有。镜头不够。。。。。。</p></blockquote><p><img data-src="https://i.loli.net/2020/10/01/ouLZczWMdQA3Crw.png" alt="Photo"></p>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我为什么重新拿出了 iPod</title>
      <link href="/2020/09/11/ipod-shuffle/"/>
      <url>/2020/09/11/ipod-shuffle/</url>
      
        <content type="html"><![CDATA[<p>我有一个 iPod Shuffle，已经吃灰多年了。。。最近重新拿出来用了。</p><a id="more"></a><h2 id="事情的起因"><a href="#事情的起因" class="headerlink" title="事情的起因"></a>事情的起因</h2><p>我订阅了 Apple Music，挺不错的，只是在 Phone，Mac 这些设备上，不管多么优美悦耳的音乐都成了使用设备的背景音乐。。。无法让人专心听完一首歌曲。我们似乎已经忘记之前没有这些东西时，沉静在一首歌曲中的感受了。</p><p>我拿出了这款 iPod Shuffle，有点掉色，却不影响使用。感谢，它让我找回了之前发现一首好歌、听完一首好歌的激动、欣喜与感动！闭上眼睛，静下心来，享受着属于你自己的余音绕梁的乐曲。</p><h2 id="音乐来源"><a href="#音乐来源" class="headerlink" title="音乐来源"></a>音乐来源</h2><p>有人要问了，你的乐曲从哪里来的？众所周知，现在所有的平台都有 DRM…</p><p>我购买了网易云音乐包，8元一个月，然后使用这个 <a href="http://ncm.worthsee.com">Doge</a>。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>实际上 iPod 还有一个好处，就是小巧 <del>方便带到学校去，好藏</del>。</p>]]></content>
      
      
      <categories>
          
          <category> 数码 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift 中的 SharedPreferance —— UserDefaults</title>
      <link href="/2020/08/24/swift-userdefaults/"/>
      <url>/2020/08/24/swift-userdefaults/</url>
      
        <content type="html"><![CDATA[<p>从 Android 开发又最终回到 iOS 了，好多东西都不知道。最近一直有需求要用一个类似 Android 的 SharedPreferance 的东西。找了一下资料，来总结一下。</p><a id="more"></a><h2 id="它是什么"><a href="#它是什么" class="headerlink" title="它是什么"></a>它是什么</h2><blockquote><p>不会吧？不会还有人不知道 SharedPreferance 吧？？？</p></blockquote><p><code>SharedPreferance</code> 是一种轻量级的 Android 储存API, 用于储存<strong>简单</strong>的数据，数据多了就不如其他方式高效了。</p><p>iOS 中，起同样作用的东西，叫 <code>UserDefaults</code>。</p><p>这两者都以 <code>key-value</code> 的形式存储。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><strong>简单数据</strong></p><p><strong>简单数据</strong></p><p><strong>简单数据</strong></p><p>复杂数据建议使用 <code>SQLite</code> 或者 <code>Core Data</code>，不建议作死。。。</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>直接上代码，里面注释我都写好了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaults <span class="operator">=</span> <span class="type">UserDefaults</span>.standard <span class="comment">// 获取全局的 UserDefaults</span></span><br><span class="line"></span><br><span class="line">defaults.set(<span class="type">Int</span>.max, forKey: <span class="string">&quot;int&quot;</span>) <span class="comment">// 存储</span></span><br><span class="line">defaults.integer(forKey: <span class="string">&quot;int&quot;</span>) <span class="comment">// 读取</span></span><br><span class="line"></span><br><span class="line">defaults.set(<span class="literal">true</span>, forKey: <span class="string">&quot;bool&quot;</span>)</span><br><span class="line">defaults.bool(forKey: <span class="string">&quot;bool&quot;</span>)</span><br><span class="line"></span><br><span class="line">defaults.set(<span class="type">Double</span>.infinity, forKey: <span class="string">&quot;double&quot;</span>)</span><br><span class="line">defaults.double(forKey: <span class="string">&quot;double&quot;</span>)</span><br><span class="line"></span><br><span class="line">defaults.set(<span class="type">Float</span>.infinity, forKey: <span class="string">&quot;float&quot;</span>)</span><br><span class="line">defaults.float(forKey: <span class="string">&quot;float&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p><code>Float</code>, <code>Int</code>, <code>Double</code> 的默认值都是 0；<code>Bool</code> 的默认值是 false。</p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>大家可以多在 Playgrounds 里面试试，还可以看看 <a href="https://developer.apple.com/documentation/foundation/userdefaults">Apple Developer Documentation</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>凝视那一轮明月</title>
      <link href="/2020/08/23/stare-at-moon/"/>
      <url>/2020/08/23/stare-at-moon/</url>
      
        <content type="html"><![CDATA[<p>随便乱写的，，，要拿去参加一个小比赛。。。</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>初夏，深夜，我却还在熬夜赶作业。</p><p>夜里，恍惚着，偶然向窗外望了望。多完美的一轮明月啊！</p><p>凝视这一轮明月，它明亮，照白了月边稀疏的云；它洁净，仿佛世间没有什么比它跟洁白如雪；它深邃，好像有不尽的秘密。周围繁星点点，如同月亮的伙伴，与她共欢笑。明朗的夜空，月亮和繁星点缀，让这个夜晚，显得十分安静祥和。</p><p>我不禁陷入无尽的想象。月儿啊！这孤独的夜，你有着星星的陪伴，与我不同！月儿啊！夜深人静时，你怎么还没入睡？是否和我一样，还在努力奋斗？月儿啊！一个个夜晚，你是否感觉有点烦闷？……</p><p>想着想着，我突然想到：身处闹市区，是如何见到这样的明月的？这夜空明朗的，让人惊奇，我从未见过。这夜空，不应该满是雾霾、尘埃吗？</p><p>我回想起，好多年前，那也是一个这样的的夜晚，我和朋友们在路口乘凉，可能才刚上小学。</p><p>抬眼望去，一片灰蒙蒙的天，几乎看不清什么月亮，更别提星星了。那时候，上海的明朗的夜晚并不是天天有。</p><p>“这月儿，今天晚上又躲起来了，看不清了。”一旁的嘉豪一边向天上凝视，一边说。但是，最终他还是未能知晓月儿的真面目。</p><p>“环境污染太严重了，那些工厂、车辆，人类生活影响到了环境。”我说着，仿佛看到了远处郊区的几座大工厂，烟还在不断上升到大气中。</p><p>嘉豪打了个哈欠。现在已经是夜深人静时，远处的卡车的声音，很清楚，又很微弱。老师讲过，有些卡车用的油不符合标准，排放出来很是污染环境。我们站在这路口，似乎还能闻到汽油发出的一种难闻的味道。</p><p>这路口，昏黄的路灯还在亮着，高楼大厦还在发着光。“书上说，大部分的电力还是来自不清洁能源。”喜爱读书的嘉豪说。一个晚上，这灯火通明的闹市区，不知要浪费多少电呢。</p><p>夜深了，我记不起后面说了什么，想了什么。</p><p>恍惚间，我又陷入了沉思。啊，我的月儿！你看起来有些孤独！没有星星的陪伴，你还好吗！啊，我的月儿！你听见这卡车的声音，问道汽油的味道了吗？啊，我的月儿！这样一个夜晚，你却躲了起来，是有什么秘密吗？<br>……<br>夜晚，有些凉，我被冻醒，已经凌晨二三点了吧。</p><p>我再次举头凝视天边的月亮。诶？月亮怎么又躲起来了？我望向桌上杂乱摆放的作业。诶？我的作业怎么已经写完了！原来，一切，是梦。作业写完后，我太累了，就在书桌上睡着了。</p><p>我的月亮，答应我，以后不要再躲起来了？我都能见到你和星星，在无数个静寂而孤独的夜！答应我，让我梦想成真，好吗？</p><p>将来，我再次凝视那一轮明月……</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 散文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 GitHub Actions 部署 Hexo 博客</title>
      <link href="/2020/08/22/gh-action-hexo/"/>
      <url>/2020/08/22/gh-action-hexo/</url>
      
        <content type="html"><![CDATA[<p>最近有一个朋友找我，说她弄了一个 Hexo 博客，想做 GitHub Actions 自动部署，奈何不会弄，只好让我帮忙。</p><a id="more"></a><h2 id="GitHub-Actions"><a href="#GitHub-Actions" class="headerlink" title="GitHub Actions"></a>GitHub Actions</h2><p><a href="https://docs.github.com/en/actions">GitHub Actions</a> 是 GitHub 推出的持续集成服务，最近不要钱了，用(白嫖)的人就多起来了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>话不多说，直接上代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;Hexo Blog Builder&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>, <span class="string">pull_request</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;Hexo Blog Build&quot;</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">fetch-depth:</span> <span class="number">1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&#x27;12&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Hexo</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Clean</span> <span class="string">Previous</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">rm</span> <span class="string">-rf</span> <span class="string">docs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">Clean</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Generate</span> <span class="string">New</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Move</span> <span class="string">docs/</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">mv</span> <span class="string">public</span> <span class="string">docs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Publish</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          mkdir -p ~/.ssh/</span></span><br><span class="line"><span class="string">          echo &quot;$&#123;&#123; secrets.KEY &#125;&#125;&quot; &gt; ~/.ssh/id_rsa.pub</span></span><br><span class="line"><span class="string">          chmod 600 ~/.ssh/id_rsa.pub</span></span><br><span class="line"><span class="string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string">          git config --global user.name &quot;Hexo Deploy Bot&quot;</span></span><br><span class="line"><span class="string">          git config --global user.email &quot;nobody@nobody.nobody&quot;</span></span><br><span class="line"><span class="string">          git config --global core.quotepath false</span></span><br><span class="line"><span class="string">          git add --all</span></span><br><span class="line"><span class="string">          git commit -m &quot;Hexo Blog Build&quot;</span></span><br><span class="line"><span class="string">          git push origin master</span></span><br></pre></td></tr></table></figure><p>本 Action 需要你的 ssh 公钥，也就是 <code>id_rsa.pub</code> 存在项目设置中的 Secrets 内。</p><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>具体实现很简单，用 Hexo 自带生成器生成到 <code>public</code> 目录，把 <code>public</code> 目录改名为 <code>docs</code>。最后 <code>push</code> 到项目里。</p><p><code>push</code> 使用 SSH Key，实现免密码。</p><p>在 GitHub Pages 设置中，需要把 Source 改为 docs 目录。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如果大家有什么改进的好方法，可以在下方评论！</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迟来的日志 - WWDC 2020 奖学金</title>
      <link href="/2020/08/19/wwdc2020/"/>
      <url>/2020/08/19/wwdc2020/</url>
      
        <content type="html"><![CDATA[<p>今年 6 月份，因为疫情的影响，WWDC改为线上，之前的奖学金重命名为 <a href="https://developer.apple.com/wwdc20/swift-student-challenge/">Swift Student Challenge</a>。</p><p>我老早就有参加这一活动的打算，只是一直没能实现，也没有达到要求。今年大胆尝试了一会，虽然成绩不理想，但还是收获了许多。</p><p>我今年的项目在 <a href="https://github.com/aeilot/WWDC2020">aeilot/WWDC2020</a>。</p><a id="more"></a><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>今年我的项目使用了 SwiftUI 和 SpriteKit。我做了一个 2D 的跑酷类游戏，内容是关于 COVID19 的。</p><p>整体开发下来，多亏了 Apple Document，里面的文档很详细，还有示例，👍。</p><p><img data-src="https://i.loli.net/2020/08/20/BXzAlu5jIvNg76O.png" alt="Apple Document"></p><p>当然开发中遇到的几个问题，我也是在 Apple Developer Forums 和 Stack Overflow 解决的。具体链接就不写了，社区很活跃，10分钟就有人回答了。</p><p>只是开发太赶，只有不到一个星期，决定参加都花了几天，🤦‍♀️。。。所以最后成果像一个半成品。。。</p><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>关于明年的 WWDC，我想我是一定会去参加的！最好早点准备，加油！等着我的好消息！</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> WWDC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vcpkg - 方便的 C/C++ 库管理器</title>
      <link href="/2020/08/13/vcpkg/"/>
      <url>/2020/08/13/vcpkg/</url>
      
        <content type="html"><![CDATA[<p>最近在做一个大型的 C++ 项目 ── <a href="https://github.com/louis-studio/Albumist">Albumist</a>。它使用 Qt，需要用到很多类似 <code>sqlite3</code>、<code>exiv2</code>、<code>libcurl</code> 之类的库。第三方库管理似乎成了问题。</p><p>支持 git 的都可以使用　<code>git submodule</code> 来管理，但是还有少部分是不支持的，或者是二进制的，比如 <code>sqlite3</code>。这就要我们手动去下载，手动去更新，好生麻烦。</p><a id="more"></a><h2 id="vcpkg"><a href="#vcpkg" class="headerlink" title="vcpkg"></a>vcpkg</h2><p>我一直想要一个类似 <code>npm</code> <code>pip</code> 一样的东西，把依赖写在文件里面，然后直接 <code>install</code> 即可。</p><p>经过搜索，我发现了微软的一个项目 <a href="https://github.com/microsoft/vcpkg/">vcpkg</a>。官方定义它为 “C++ Library Manager for Windows, Linux, and MacOS”，简单翻译一下就是 “支持 Windows, Linux 和 macOS 的 C++ 库管理器”。</p><p>在 Arch Linux 上面，安装它并不复杂，只需要：<code>sudo pacman -S vcpkg-git</code> 即可。其他系统没有尝试过，跟着它的 README 也很方便安装。</p><h2 id="“清单”-功能"><a href="#“清单”-功能" class="headerlink" title="“清单” 功能"></a>“清单” 功能</h2><p>在项目根目录创建一个 <code>vcpkg.json</code>， 然后 <code>vcpkg install</code>。这一功能就是“清单”功能。它正好是我想要的，可是却暂时处在 Beta 阶段，不过也无关紧要。</p><p>要启用“清单”功能，在执行命令时，需要接参数 <code>--feature-flags = manifests</code>。</p><p>清单大概长这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;&lt;name of your project&gt;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version-string&quot;</span>: <span class="string">&quot;&lt;version of your project&gt;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;abseil&quot;</span>,</span><br><span class="line">    <span class="string">&quot;boost&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很方便，也很快捷。</p><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>比起这样一个纯粹的管理器，我更希望获得类似 Java 的 Gradle 的体验。如果 CMake 能加入类似功能，体验一定能够翻倍，快捷方便且无需第三方软件。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>—- 2020 08 15 更新</p><p>又停止使用这个东西了，Windows 上面需要 MSVC。。。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vimrc 配置指南</title>
      <link href="/2020/07/26/vimrc/"/>
      <url>/2020/07/26/vimrc/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://www.vim.org/images/vim_header.gif" alt="Vim"></p><p>Vim 即 Vi Improved，它的前身是 Vi。它是一个十分强大的编辑器，优点如下：</p><ul><li>不需要鼠标，纯键盘</li><li>Linux 系统预装</li><li>键盘命令肌肉记忆之后，效率非常高</li></ul><p>但是，它的配置许许多多，让人难以记住。我正好要在新电脑上配置它，故写此文。<br><a id="more"></a></p><h3 id="为什么不用别人现成的？"><a href="#为什么不用别人现成的？" class="headerlink" title="为什么不用别人现成的？"></a>为什么不用别人现成的？</h3><ol><li>自己的配置更顺手，自己更熟悉。</li><li>了解 Vim Script，可以自己造插件</li><li>etc.</li></ol><h2 id="不会-Vim-怎么办"><a href="#不会-Vim-怎么办" class="headerlink" title="不会 Vim 怎么办"></a>不会 Vim 怎么办</h2><p>啊这…… 🤣 </p><p>你可以试着在命令行输入 <code>vimtutor</code>。</p><h2 id="vimrc-的位置"><a href="#vimrc-的位置" class="headerlink" title="vimrc 的位置"></a>vimrc 的位置</h2><p>本篇文章以新安装的 vim 为例。Vim 的配置文件叫做 <code>vimrc</code>。在 Mac、Linux 等系统上，位于 <code>~/.vimrc</code>。在 Windows 系统中，它叫做 <code>_vimrc</code>，但是同样位于 Home 目录中。</p><p>全局的配置，在 Mac、Linux 等系统上，位于 <code>/etc/vimrc</code>。在 Windows 系统上，它储存在 Vim 安装目录，同样叫做 <code>vimrc</code>。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>一个什么也没有配置的 Vim，打开可能是这样的:  </p><p><img data-src="https://i.loli.net/2020/07/25/VSRZMUnjOfDzq8b.png" alt="image.png"></p><p>下面各配置，你可以添加自己想要的。以下所有配置都可以在命令模式输入，临时启用或关闭。</p><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> nocompatible <span class="comment">&quot; 不使用 Vi 兼容模式</span></span><br><span class="line"><span class="keyword">filetype</span> plugin <span class="keyword">on</span>  <span class="comment">&quot; 检测文件类型，加载插件</span></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span> <span class="comment">&quot; 开启语法高亮</span></span><br><span class="line"><span class="keyword">set</span> showmode <span class="comment">&quot; 显示当前模式</span></span><br><span class="line"><span class="keyword">set</span> showcmd <span class="comment">&quot; 在底部显示命令</span></span><br><span class="line"><span class="keyword">set</span> mouse=<span class="keyword">a</span> <span class="comment">&quot; 启用鼠标，不建议开启</span></span><br><span class="line"><span class="keyword">set</span> encoding=utf-<span class="number">8</span>  </span><br><span class="line"><span class="keyword">set</span> t_Co=<span class="number">256</span></span><br><span class="line"><span class="keyword">filetype</span> <span class="built_in">indent</span> <span class="keyword">on</span> <span class="comment">&quot; 根据文件类型，不同缩进</span></span><br></pre></td></tr></table></figure><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autoindent <span class="comment">&quot; 自动缩进</span></span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span> <span class="comment">&quot; tab占4个空格</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span> <span class="comment">&quot; 在文本上按下&gt;&gt;（增加一级缩进）、&lt;&lt;（取消一级缩进）或者==（取消全部缩进）时，每一级的空格数。</span></span><br><span class="line"><span class="keyword">set</span> expandtab <span class="comment">&quot; tab自动转为空格</span></span><br><span class="line"><span class="keyword">set</span> softtabstop=<span class="number">2</span> <span class="comment">&quot; tab转为多少空格</span></span><br></pre></td></tr></table></figure><h3 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">number</span> <span class="comment">&quot; 显示行号</span></span><br><span class="line"><span class="keyword">set</span> relativenumber <span class="comment">&quot; 显示光标所在行当前行号，其他都显示为相对于当前行的行号</span></span><br><span class="line"><span class="keyword">set</span> cursorline <span class="comment">&quot; 当前行高亮</span></span><br><span class="line"><span class="keyword">colorscheme</span> default <span class="comment">&quot; 设置颜色主题为 default，颜色主题储存在 Home 目录的 .vim/colors 文件夹，Windows 下叫做 vimfiles/colors</span></span><br><span class="line"><span class="keyword">set</span> wrap <span class="comment">&quot; 设置多于行宽的文本自动分拆为多行显示，反之: set nowrap</span></span><br><span class="line"><span class="keyword">set</span> linebreak <span class="comment">&quot; 遇到特殊的符号才折行</span></span><br><span class="line"><span class="keyword">set</span> laststatus=<span class="number">2</span> <span class="comment">&quot; 是否显示状态栏。0 不显示，1 只在多窗口时显示，2 显示。</span></span><br><span class="line"><span class="keyword">set</span> ruler <span class="comment">&quot; 状态栏显示光标位置</span></span><br><span class="line"><span class="keyword">set</span> showmatch <span class="comment">&quot; 高亮括号</span></span><br></pre></td></tr></table></figure><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> hlsearch <span class="comment">&quot; 高亮搜索结果</span></span><br><span class="line"><span class="keyword">set</span> incsearch <span class="comment">&quot; 搜索输入时，即时跳转</span></span><br><span class="line"><span class="keyword">set</span> ignorecase <span class="comment">&quot; 忽略大小写</span></span><br></pre></td></tr></table></figure><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>Vim 配置不止这些，我只介绍了一些常用的。Vim Script 值得学习，学完了还可以自己开发插件。</p><h2 id="题外话-插件"><a href="#题外话-插件" class="headerlink" title="题外话 - 插件"></a>题外话 - 插件</h2><p>插件管理，Vim 虽然新增了自带的，但我还是很推荐 <a href="https://github.com/junegunn/vim-plug">Vim-Plug</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 编辑器 </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NextCloud - DIY NAS 解决方案</title>
      <link href="/2020/07/23/nextcloud/"/>
      <url>/2020/07/23/nextcloud/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://avatars0.githubusercontent.com/u/19211038?s=200&amp;v=4" alt="LOGO"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我之前给家中的服务器做了一个 WebDAV 功能，带有不堪入目的 UI 和难以使用的功能。而且配置起来并不简单。一直想要改进，但是却一直没时间。最近有空了，便开始寻找替代品。</p><p>查了几下 GitHub，找到了一个标星 10k+ 的项目 —— <a href="https://github.com/nextcloud/">NextCloud</a>。了解了一下，NextCloud 是一个拥有 <strong>全平台客户端</strong>，支持 <strong>WebDAV</strong>，而且 <strong>插件化</strong>，可以 <strong>多用户</strong> 使用的私有云存储网盘项目。不仅如此，它还支持共享、版本控制、团队协作等功能。插件化让它拥有了类似 Markdown 在线编辑，Draw-io 在线编辑，显示 RAW 文件的功能。</p><p>而且，我发现它支持 Docker，这无疑简化了我们配置的步骤。</p><p>那么，我们开始吧！</p><a id="more"></a><h2 id="Docker-配置"><a href="#Docker-配置" class="headerlink" title="Docker 配置"></a>Docker 配置</h2><p>Docker 安装很简单，为了安装快速，你可以参考清华大学开源镜像站给出的 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/">文档</a>。如果你已经安装了 Docker, 那么可以忽略这一步。</p><p>更换镜像也是让你更快体验的必不可少的一步，修改 <code>/etc/docker/daemon.json</code> 文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span> : [</span><br><span class="line">    <span class="string">&quot;http://registry.docker-cn.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://docker.mirrors.ustc.edu.cn&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://hub-mirror.c.163.com&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span> : [</span><br><span class="line">    <span class="string">&quot;registry.docker-cn.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;docker.mirrors.ustc.edu.cn&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="安装-NextCloud"><a href="#安装-NextCloud" class="headerlink" title="安装 NextCloud"></a>安装 NextCloud</h2><p>运行如下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d \</span><br><span class="line">        --name nextcloud \</span><br><span class="line">        -p 8000:80 \</span><br><span class="line">        -v &lt;数据储存位置&gt;:/var/www/html \</span><br><span class="line">        nextcloud</span><br></pre></td></tr></table></figure><p>如果遇到如下问题：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br></pre></td></tr></table></figure><p>可以运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置这一部分很简单，不用解释了。</p><p>选择数据库时，使用量小可以选择 SQLite，但是并不推荐。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>NextCloud 还是非常稳定的，基本配置完之后不会遇到什么问题。而且原生支持中文，只需要在设置中设置一下就可以了。</p><p>我主要用它储存我的照片，摄影还有一些不需要经常查看的文件。由于自己服务器性能不错，用起来很流畅，完全没必要买现成的，硬盘不够再买一个即可。</p>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sudo shutdown -r now</title>
      <link href="/2020/07/22/helloworld/"/>
      <url>/2020/07/22/helloworld/</url>
      
        <content type="html"><![CDATA[<p>你可能会惊奇地发现博客上面以前的文章全不见了。<strong>最近我对我博客进行了一次大清扫</strong>。</p><a id="more"></a><p><strong>tl;dr</strong></p><p>前几天，我突然发现自己的博客上面全是水文（以前就知道，懒得弄），心里总觉得过不去。所以，我下定决心，准备重新来过。这种感觉很好，当<code>_posts</code>目录空无一物时，我的心也释然了。</p><p>之前我所有的文章，要么是抄袭的，要么是很水的那种。<strong>在这里，我承诺，以后不再会有这种不可饶恕的情况发生了</strong>。这样做我自己心里也总是想着缺点什么。幸幸苦苦修改的自定义hexo主题（没错，我把 <a href="https://github.com/probberechts/hexo-theme-cactus">hexo-theme-cactus</a> 修改了很多，支持了 RSS，还弄了些 UI 改进，配置了 Valine.js，etc.），结果呢？上面全是水文！？这……</p><p>那么之前的文章都去哪里了呢？我并没有删除，而是把它们放置在了 <code>Draft</code> 目录下面，当然，你们看不到。<strong>手动狗头</strong></p><p>让我们重新认识对方，运行一次<code>sudo shutdown -r now</code>！</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
